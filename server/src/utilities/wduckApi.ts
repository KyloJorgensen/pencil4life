'use strict';
import fetch, { Request, RequestInit } from 'node-fetch';

export interface SubmitMessageOptions {

  user?:	string;
  // Users unique ID

  reference?:	{
  // Optional referenced email. If submitted message is a reply and relevant fields are not provided then these are resolved from the message to be replied to
  
    mailbox: string;
    // Mailbox ID

    id: number;	
    // Message ID in Mailbox

    action:	string;
    // Either reply, replyAll or forward  

  };	

  mailbox?:	string;
  // Mailbox ID where to upload the message. If not set then message is uploaded to Sent Mail folder.

  uploadOnly?: boolean;	
  // If true then generated message is not added to the sending queue
  // Default value: false

  isDraft?: boolean;
  // If true then treats this message as draft (should be used with uploadOnly=true)
  // Default value: false

  sendTime?:	string;
  // Datestring for delivery if message should be sent some later time

  envelope?:	{
  // SMTP envelope. If not provided then resolved either from message headers or from referenced message

    from?: {
    // Sender information. If not set then it is resolved to User's default address

      address:	string;
      // Sender address. If this is not listed as allowed address for the sending User then it is replaced with the User's default address
  
    };	

    to?: {
    // Recipients information

      address:	string;
      // Recipient address

    }[];

  };

  from?:	{
  // Address for the From: header

    name:	string;
    // Name of the sender

    address:	string;
    // Address of the sender

  };

  to?: {
  // Addresses for the To: header

    name?:	string;
    // Name of the recipient

    address:	string;
    // Address of the recipient

  }[];

  cc?: {
  // Addresses for the Cc: header

    name?:	string;
    // Name of the recipient

    address:	string;
    // Address of the recipient

  }[];

  bcc?: {
  // Addresses for the Bcc: header

    name?:	string;
    // Name of the recipient

    address:	string;
    // Address of the recipient

  }[];

  subject:	string;
  // Message subject. If not then resolved from Reference message

  text?:	string;
  // Plaintext message

  html?:	string;
  // HTML formatted message

  headers?: {
  // Custom headers for the message. If reference message is set then In-Reply-To and References headers are set automatically
    
    key:	string;
    // Header key ('X-Mailer')

    value:	string;
    // Header value ('My Awesome Mailing Service')

  }[];

  attachments?: {
  // Attachments for the message

    content:	string;
    // Base64 encoded attachment content

    filename?:	string;
    // Attachment filename

    contentType?:	string;
    // MIME type for the attachment file

    cid?:	string;
    // Content-ID value if you want to reference to this attachment from HTML formatted message

  }[];

  meta?: {
  // Custom metainfo for the message

    sess?:	string;
    // Session identifier for the logs

    ip?:	string;
    // IP address for the logs
  };

}

export interface NewUserOptions {

  username: string;	
  // Username of the User. Dots are allowed but informational only ("user.name" is the same as "username").
  
  password: string | false;	
  // Password for the account. Set to boolean false to disable password usage
  
  address?: string;	
  // Default email address for the User (autogenerated if not set)
  
  emptyAddress?: boolean;	
  // If true then do not autogenerate missing email address for the User. Only needed if you want to create an user account that does not have any email address associated
  
  requirePasswordChange?: boolean;	
  // If true then requires the user to change password, useful if password for the account was autogenerated
  
  tags?: string[];	
  // A list of tags associated with this user
  
  addTagsToAddress?: boolean;	
  // If true then autogenerated address gets the same tags as the user
  
  retention?: number;	
  // Default retention time in ms. Set to 0 to disable
  
  encryptMessages?: boolean;	
  // If true then received messages are encrypted
  
  encryptForwarded?: boolean;	
  // If true then forwarded messages are encrypted
  
  pubKey?: string;	
  // Public PGP key for the User that is used for encryption. Use empty string to remove the key
  
  language?: string;	
  // Language code for the User
  
  targets?: string[];	
  // An array of forwarding targets. The value could either be an email address or a relay url to next MX server ("smtp://mx2.zone.eu:25") or an URL where mail contents are POSTed to
  
  spamLevel?: number;	
  // Relative scale for detecting spam. 0 means that everything is spam, 100 means that nothing is spam
  // Default value: 50
  
  quota?: number;	
  // Allowed quota of the user in bytes
  
  recipients?: number;	
  // How many messages per 24 hour can be sent
  
  forwards?: number;	
  // How many messages per 24 hour can be forwarded
  
  imapMaxUpload?: number;	
  // How many bytes can be uploaded via IMAP during 24 hour
  
  imapMaxDownload?: number;	
  // How many bytes can be downloaded via IMAP during 24 hour
  
  pop3MaxDownload?: number;	
  // How many bytes can be downloaded via POP3 during 24 hour
  
  receivedMax?: number;	
  // How many messages can be received from MX during 1 hour
  
  sess?: string;	
  // Session identifier for the logs
  
  ip?: string;	
  // IP address for the logs

}

export const fetchFromWDuckApi = (endpoint: string, requestInit?: RequestInit) => {
  requestInit = requestInit || {};
  if ('method' in requestInit) {
    if (requestInit.method.toLocaleUpperCase() != "GET") {
      requestInit.headers = requestInit.headers || {}; 
      requestInit.headers['Content-Type'] = 'application/json';
    }
  }
  let request = new Request(`http://localhost:8080${endpoint}`, requestInit);

  return fetch(request).then((response) => {
      if (response.status < 200 || response.status >= 300) {
          const error = new Error(response.statusText);
          error.message = JSON.stringify(response);
          throw error;
      }
      return response.json();
  }).then((info) => {
    return info;
  })
};

export const getUserId = (username: string) => {
  return fetchFromWDuckApi('/users')
  .then((users) => {
    if (users.success) {
      const userindex = users.results.findIndex((user) => {
        return user.username == username;
      });

      if (userindex != -1) {
        return users.results[userindex].id;
      }
      return null;
    } else {
      throw new Error('Failed to get users');
    }
  })
};

export const newUser = (username: string, newUserOptions: NewUserOptions) => {
  return fetchFromWDuckApi('/users', {
    method: 'POST',
    body: JSON.stringify(newUserOptions),
  })
  .then((user) => {
    if (user.success == true) {
      return user.id;
    } else {
      throw new Error(user.error);
    }
  })
};

export const submitMessage = (submitMessageOptions: SubmitMessageOptions) => {
  const username = 'noreply';
  return getUserId(username)
  .then((userId: string | null) => {
    if (userId) {
      return userId;
    } else {
      return newUser(username, {
        username: username,
        password: false,
        receivedMax: 0,
      });
    }
  }).then((userId) => {
    return fetchFromWDuckApi(`/users/${userId}/submit`, {
      method: 'POST',
      body: JSON.stringify(submitMessageOptions),
    });
  }).then((info) => {
    return info;
  })
};


